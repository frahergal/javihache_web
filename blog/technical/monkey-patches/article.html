<meta name="‚Äùrobots‚Äù" content="‚Äùnoindex‚Äù" />
<!-- Template file for common content in blog pages-->
<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!--Styles -->
    <link rel="stylesheet" href="../../../css/index.css" />
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Sixtyfour&display=swap"
      rel="stylesheet"
    />
    <!-- Libraries -->
    <script async src="../../../libs/prism/prism.js"></script>
    <link href="../../../libs/prism/prism.css" rel="stylesheet" />
    <!-- Title -->
    <title>javihache.dev - Monkey patches</title>
  </head>

  <div id="header"></div>
  <body>
    <main>
      <h2>Monkey patches</h2>
      <p>¬øSabes qu√© son los parches de mono o <i>monkey patches</i>? üêí</p>
      <p>
        Probablemente los hayas visto antes o incluso los hayas implementado sin
        darte cuenta. En este post te voy a aclarar este concepto para
        introducir <i>hotfixes</i> o parches en tu c√≥digo.
      </p>
      <img
        src="./imgs/monkey_patches_card.png"
        alt="Imagen con el texto Monkey Patches y un dibujo de un mono"
      />
      <p>
        Un <i>monkey patch</i> es una expresi√≥n que se utiliza para aquellos
        cambios o parches que se hacen durante tiempo de ejecuci√≥n a
        funcionalidades que ya han sido implementadas en nuestro c√≥digo o en
        librer√≠as o componentes externos.
      </p>
      <p>
        Esta t√©cnica se utiliza normalmente para modificar una l√≥gica especifica
        y arreglar algunos casos aislados temporalmente.
      </p>
      <p>Un ejemplo en Javascript podr√≠a ser el siguiente:</p>
      <pre>
        <code class="lang-js">
            // Create a class with a defined behaviour
            class Monkey {
              constructor(name) {
                this.name = name;
              }
            
              sayMyName() {
                console.log(this.name);
              }
            }
            
            // Create a couple of Monkey instances
            let monkeyAndrew = new Monkey("Andrew");
            let monkeyRyan = new Monkey("Ryan");
            
            // Monkey Patch the method "sayMyName" 
            // for the instance monkeyAndrew
            monkeyAndrew.sayMyName = () => {
              console.log(monkeyAndrew.name + " I");
            };
            
            // Call to the method "sayMyName"
            monkeyAndrew.sayMyName();
            monkeyRyan.sayMyName();
        </code>
      </pre>
      <p>Al ejecutarlo nos devolver√≠a lo siguiente:</p>
      <pre>
        <code class="lang-shell">
            Andrew I
            Ryan
        </code>
      </pre>
      <p>
        Como puedes ver, lo que hemos hecho ha sido aplicar un
        <i>Monkey patch</i> a la instancia <code>monkeyAndrew</code> de nuestra
        clase <code>Monkey</code>. De esta forma el cambio en el comportamiento
        de nuestro c√≥digo ha afectado solamente a un objeto en cuesti√≥n y no al
        resto.
      </p>
      <p>
        Los <i>Monkey patches</i> tambi√©n pueden aplicarse a librer√≠as o
        componentes externos si el lenguaje o frameworks permite tales
        modificaciones. Por ejemplo, en Python:
      </p>
      <pre>
        <code class="lang-python">
            >>> import math

            # Print PI
            >>> math.pi
            3.141592653589793

            # Monkey patch PI and print it
            >>> math.pi = 3.1
            >>> math.pi
            3.1
        </code>
      </pre>
      <p>
        Esta pr√°ctica puede ser realmente √∫til si hay un caso espec√≠fico en el
        que nos interesa cambiar el comportamiento de un componente por defecto.
        A pesar de todo, no es muy recomendable aplicar este tipo de parches.
        Introducir <i>Monkey patches</i> en tu c√≥digo crea una l√≥gica que no es
        la esperaday puede inducir errores o comportamientos extra√±os que m√°s
        adelante ser√°n dif√≠ciles de identificar.
      </p>
      <p>
        Puede tener cierto sentido aplicar este tipo de parches en los tests
        unitarios. Cuando creamos un <i>stub</i> o un <i>mock</i> de un m√©todo
        para obtener datos sin llamar al m√©todo real. En cualquier otro caso es
        posible que haya mejores soluciones, como extender la clase o la funci√≥n
        que necesitemos parchear para a√±adirle la funcionalidad deseada.
      </p>
    </main>
  </body>

  <div id="footer"></div>
  <script src="../../../index.js"></script>
</html>
